@using System.Configuration
@{
	ViewBag.Title = "D3.js";
}

@section style{
	<style>
		svg {
			border: 1px solid rgb(160, 160, 160);
			width: 100%;
			height: 100%;
		}

		.node {
			stroke-width: 1.5px;
		}

		.edge {
			stroke-width: 1px;
			fill: none;
		}

		#sigma-chart {
			border: 1px solid gray;
		}

		#vivaContainer {
			width: 100%;
			height: 600px;
			margin: 0;
		}
	</style>
}

<div id="ctrlzone" ng-controller="mainController" style="display: none;">

	<div class="text-danger" ng-if="ownerid.length == 0" style="font-size: 16px;">
		?id=your_id
	</div>

	<div ng-if="ownerid.length != 0">
		<progressbar ng-show="lock && calcWith() != 100" class="progress-striped active" value="calcWith()" type="info">loading...</progressbar>
		<button ng-show="calcWith() != 100" class="btn btn-info" ng-click="loadData()">Load Info</button>

		<div ng-show="calcWith() == 100">
			<tabset>
				<tab heading="D3 render">
					<div ng-controller="d3Controller">
						<table style="margin-top: 10px;" class="table table-striped table-bordered">
							<tr>
								<td><button class="btn btn-info btn-block" ng-click="createGraph()">Create graph</button></td>
								<td>Ignore border</td>
								<td><input type="text" ng-model="config.ignore" style="width: 60px;" /></td>
								<td>Dot distance</td>
								<td><input type="text" ng-model="config.dist" style="width: 60px;" /></td>
								<td>Dot radius</td>
								<td><input type="text" ng-model="config.rad" style="width: 60px;" /></td>
							</tr>
						</table>
					</div>
					<div style="margin-top: 20px;" svgfriend></div>
				</tab>
				<tab heading="Viva render">
					<div ng-controller="vivaController">
	<table style="margin-top: 10px;" class="table table-striped table-bordered">
		<tr>
			<td>
				<button class="btn btn-info" ng-click="createGraph()">Create graph</button>
			</td>
		</tr>
	</table>
	<div id="vivaContainer"></div>
</div>
				</tab>
			</tabset>
		</div>
	</div>
</div>

@section scripts
{
	<script src="~/jsApp/svg.vk.profile.js"></script>

	<script type="text/javascript">
		'use sctrict';

		var graph;

		$(document).ready(function () {
			$('#ctrlzone').show();

			graph = Viva.Graph.graph();
			var mnode = graph.addNode('target');
			var renderer = Viva.Graph.View.renderer(graph, {
				container: document.getElementById('vivaContainer')
			});
			renderer.run();
		});

		var token = '@Html.Raw(ConfigurationManager.AppSettings["vkToken"])';
		mainModule.value('ownerid', '@Html.Raw(ViewBag.ID)');

		var bd = { data: [], friends: [], bigdata: [] };

		mainModule.factory('sharedRepo', function (mockService) {
			var repo = {
				data: [],
				friends: []
			};

			return {
				get: function () {
					return mockService.get();
				}
			};
		});

		mainModule.controller('mainController', ['$scope', '$timeout', 'sharedRepo', 'vkService', 'ownerid',
			function (s, t, sharedRepo, vk, ownerid) {
				var repo = sharedRepo.get(),
					callTimer = 0;

				s.ownerid = ownerid;
				s.load = 0;
				s.lock = false;

				s.getFriends = function (id) {
					if (!_.isEmpty(id)) {
						vk.friendsGet(id, 'last_name').then(function (r) {
							repo.friends = angular.copy(r);
							bd.friends = angular.copy(r);
						});
					}
				};

				s.calcWith = function () {
					return 100;
					//return s.load / repo.friends.length * 100;
				};

				s.loadData = function () {
					if (!s.lock) {
						var data = _.map(repo.friends, function (r) { return { uid: r.uid, name: r.last_name + ' ' + r.first_name }; });
						_.each(data, function (f) {
							callTimer += 1000;
							t(function () {
								vk.friendsGet(f.uid, 'last_name').then(function (r) {
									s.load++;
									if (typeof r != 'undefined' && r.length != 0) {
										repo.data.push({ uid: f.uid, name: f.name, friends: r });
										bd.data.push({ uid: f.uid, name: f.name, friends: r });
									}
								});
							}, callTimer);
						});
					}
					s.lock = true;
				};

				// FAKE start
				(function () {
					s.lock = true;
				})();

				// REAL Start
				//s.getFriends(s.ownerid);
			}]);

		mainModule.controller('d3Controller', ['$scope', 'sharedRepo', 'ownerid',
			function (s, sharedRepo, ownerid) {
				var repo = sharedRepo.get();

				s.config = {
					ignore: 1000,
					dist: 30,
					rad: 5,
				};

				s.createGraph = function () {
					var data = angular.copy(repo.data);

					if (s.config.ignore != 0) {
						_.each(data, function (d) {
							if (d.friends.length > s.config.ignore) {
								d.friends = [];
							}
						});
					}

					var idArray = getListIntersection(data, ownerid);
					_.each(data, function (e) {
						e.friends = _.compact(_.map(e.friends, function (f) {
							if (_.contains(idArray, f.uid))
								return f;
						}));
					});

					var groupId = 1,
						graph = { links: [], nodes: [], },
						target = { uid: parseInt(ownerid), name: 'target', group: 1 };

					graph.nodes.push(target);

					_.each(data, function (e) {
						if (e.friends.length != 0) {
							groupId++;

							// проход родитель
							var p = { uid: e.uid, name: e.name.toString(), group: groupId };
							if (!isNodeExist(graph.nodes, p)) graph.nodes.push(p);
							var plink = { source: target.uid, target: p.uid };
							if (!isLinkExist(graph.links, plink)) graph.links.push(plink);

							// проход по детям
							_.each(e.friends, function (f) {
								var node = { uid: f.uid, name: f.last_name + ' ' + f.first_name, group: groupId };
								if (!isNodeExist(graph.nodes, node)) graph.nodes.push(node);

								var link = { source: p.uid, target: node.uid };
								if (!isLinkExist(graph.links, link)) graph.links.push(link);
							});
						}
					});

					var w = function () { return $('div[svgfriend]').parent().width(); };
					var h = 600;

					forcedgraph.init(w(), h, 'svgfriend', graph);
					forcedgraph.start(s.config.dist, s.config.rad);
				};

				function isNodeExist(nodes, node) {
					var r = _.filter(nodes, function (n) {
						if (n.uid == node.uid) return n;
					});

					if (r.length != 0) return true;
					else return false;
				}

				function isLinkExist(links, link) {
					var r = _.filter(links, function (l) {
						if (l.source == link.source && l.target == link.target ||
							l.source == link.target && l.target == link.source)
							return l;
					});

					if (r.length != 0) return true;
					else return false;
				}
			}]);

		mainModule.controller('vivaController', ['$scope', 'sharedRepo', 'ownerid',
			function (s, sharedRepo, ownerid) {

				var repo = sharedRepo.get();

				s.createGraph = function () {
					var data = angular.copy(repo.data);

					var idArray = getListIntersection(data, ownerid);
					_.each(data, function (e) {
						e.friends = _.compact(_.map(e.friends, function (f) {
							if (_.contains(idArray, f.uid)) return f;
						}));
					});

					_.each(data, function (e) { _.each(e.friends, function (f) { graph.addNode(f.uid); }); });
					_.each(data, function (e) { graph.addLink('target', e.uid); });
					_.each(data, function (e) { _.each(e.friends, function (f) { graph.addLink(e.uid, f.uid); }); });
				};
			}]);

		function getListIntersection(data, ownerId) {
			var idArray = [];
			var counter = 0;
			for (var i = 0; i < data.length; i++) {
				for (var j = counter; j < data.length; j++) {
					if (i !== j) {
						var current = _.compact(_.map(data[i].friends, function (f) {
							if (f.uid !== ownerId)
								return f.uid;
						}));
						var next = _.compact(_.map(data[j].friends, function (f) {
							if (f.uid !== ownerId)
								return f.uid;
						}));
						var d = _.filter(_.intersection(current, next), function (r) {
							if (r.uid !== ownerId)
								return r;
						});

						if (typeof d != 'undefined' && d.length != 0) {
							_.each(d, function (e) { idArray.push(e); });
						}
					}
				}
				counter++;
			}
			return _.uniq(idArray);
		}

		function getListIntersection2(data, ownerId) {
			var idArray = [];
			var counter = 0;
			for (var i = 0; i < data.length; i++) {
				var current = _.compact(_.map(data[i].friends, function (f) {
					if (f.uid !== ownerId)
						return f.uid;
				}));
				for (var j = counter; j < data.length; j++) {
					if (i !== j) {
						var result = _.find(current, function (e) {
							if (e == data[j].uid) return e;
						});

						if (typeof result != 'undefined') {
							idArray.push(result);
							idArray.push(data[i].uid);
						}
					}
				}
				counter++;
			}
			return _.uniq(idArray);
		}

	</script>
}